;;-*-Lisp-*-
(in-package goal)

(deftype block-camera (pov-camera) ())

(defstate pov-camera-playing (block-camera)
  :virtual #t
  :code
    (behavior ()
      (ja-no-eval :group! (ja-group) :frame-num 0.0)
      (loop
        (ja :num! (loop!))
        (suspend))))

(deftype yellow-shot (projectile-yellow) ())

(defmethod projectile-method-28 ((this yellow-shot))
  (none))

(defpart 3000
  :init-specs
  ((:texture (new 'static 'texture-id :index #xc :page #x2))
   (:birth-func 'birth-func-set-quat)
   (:num 1.0)
   (:scale-x (meters 0.9) (meters 0.225))
   (:scale-y (meters 2.52))
   (:r 0.0 44.0)
   (:g 0.0 64.0)
   (:b 128.0 32.0)
   (:a 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3 bit14 left-multiply-quat))))

(defpart 3001
  :init-specs
  ((:texture (new 'static 'texture-id :index #xc :page #x2))
   (:birth-func 'birth-func-set-quat)
   (:num 1.0)
   (:scale-x (meters 0.7) (meters 0.18))
   (:scale-y (meters 2.0))
   (:r 0.0 44.0)
   (:g 0.0 64.0)
   (:b 128.0 32.0)
   (:a 128.0)
   (:timer (seconds 0.017))
   (:flags (bit2 bit3 bit14 left-multiply-quat))))

(defun draw-eco-line ((arg0 vector) (arg1 vector) (arg2 int))
  (when (line-in-view-frustum? arg0 arg1)
    (let ((s2-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
          (gp-1 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion)))
      (vector+*! gp-1 arg0 s2-1 0.5)
      (vector-normalize-copy! s4-0 s2-1 1.0)
      (set! (-> *part-id-table* arg2 init-specs 4 initial-valuef) (vector-length s2-1))
      (forward-up->quaternion s5-0 s4-0 *y-vector*)
      (dotimes (s4-1 3)
        (quaternion-rotate-local-z! s5-0 s5-0 10922.667)
        (quaternion-copy! *particle-quat* s5-0)
        (launch-particles :system *sp-particle-system-3d* (-> *part-id-table* arg2) gp-1))))
  (none))

(defskelgroup *tntbarrel-sg*
  tntbarrel
  tntbarrel-lod0-jg
  tntbarrel-idle-ja
  ((tntbarrel-lod0-mg (meters 999999)))
  :bounds (static-spherem 0 2 0 4))

(deftype block (process-drawable)
  ((root   collide-shape-moving :override)
   (base   vector :inline)
   (offset vector :inline)
   (id     uint8)
   (lerp   float)
   (scale  vector :inline)
   (look   int)
   (target vector :inline)
   (smush  smush-control :inline)
   (notice symbol)
   (lost   symbol)
   (shift  uint))
  (:state-methods block-idle))

(deftype block-id (structure) ((id uint8)))

(define *block* (new 'static 'block-id :id 0))

(defbehavior block-init-by-other block ((trans vector) (base vector) (x-loc float) (y-loc float) (id int) (look int))
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set-root-prim! s5-0 s4-0))
    (set! (-> self root) s5-0))
  (vector-copy! (-> self root trans) trans)
  (vector-copy! (-> self base) base)
  (set! (-> self target x) x-loc)
  (set! (-> self target y) y-loc)
  (set! (-> self offset x) x-loc)
  (set! (-> self offset y) y-loc)
  (set! (-> self id) id)
  (set! (-> self look) look)
  (set-vector! (-> self scale) 1.0 1.0 1.0 1.0)
  (case look
    ((0) (initialize-skeleton self *crate-darkeco-sg* '()))
    ((1) (initialize-skeleton self *crate-iron-sg* '()))
    ((2) (initialize-skeleton self *tntbarrel-sg* '())
     (set-vector! (-> self scale) 0.43 0.43 0.43 1.0))
    ((3) (initialize-skeleton self *crate-bucket-sg* '())
     (set-vector! (-> self scale) 1.55 1.75 1.55 1.0))
    ((4) (initialize-skeleton self *crate-barrel-sg* '()))
    ((5) (initialize-skeleton self *crate-steel-sg* '()))
    ((6) (initialize-skeleton self *crate-wood-sg* '()))
    ((7) (set! (-> self part) (create-launch-control (-> *part-group-id-table* 48) self)))
    ((8) (set! (-> self part) (create-launch-control (-> *part-group-id-table* 56) self)))
    ((9) (set! (-> self part) (create-launch-control (-> *part-group-id-table* 42) self))))
  (vector-copy! (-> self root scale) (-> self scale))
  (when (< (-> self look) 6)
    (set! (-> self draw origin-joint-index) 2))
  (go (method-of-object self block-idle))
  (none))

(defstate block-idle (block)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (msg event-message-block))
    (case message
      (('place)
       (activate! (-> self smush) -0.1 75 150 1.0 1.0)
       (case (-> self look)
         ((0) (sound-play-by-spec (static-sound-spec "land-pcmetal" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((1) (sound-play-by-spec (static-sound-spec "walk-metal2" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((2) (sound-play-by-spec (static-sound-spec "walk-pcmetal1" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((3) (sound-play-by-spec (static-sound-spec "walk-wood2" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((4) (sound-play-by-spec (static-sound-spec "walk-wood1" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((5) (sound-play-by-spec (static-sound-spec "land-metal" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
         ((6) (sound-play-by-spec (static-sound-spec "land-wood" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))))
      (('break)
       (case (-> self look)
         ((7) (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 49) -1 #f #f #f (-> self root trans) :to *entity-pool*))
         ((8) (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 57) -1 #f #f #f (-> self root trans) :to *entity-pool*))
         ((9) (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 43) -1 #f #f #f (-> self root trans) :to *entity-pool*))
         (else (process-spawn part-tracker :init part-tracker-init (-> *part-group-id-table* 72) -1 #f #f #f (-> self root trans) :to *entity-pool*)))
       (deactivate self))
      (('lose)
       (set! (-> self lost) #t)
       (set! (-> self target y) (+ (-> self target y) (meters 200)))
       (set! (-> self lerp) 0.001))
      (('notice)
       (set! (-> self notice) #t))
      (('move-delay)
       (set! (-> self base x) (the-as float (-> msg param 0)))
       (if (<= (-> self look) 6)
         (set! (-> self base y) (the-as float (-> msg param 1)))
         (set! (-> self base y) (+ (the-as float (-> msg param 1)) (meters 1.0))))
       (set! (-> self base z) (the-as float (-> msg param 2))))
      (('set-loc)
       (set! (-> self target x) (the-as float (-> msg param 0)))
       (set! (-> self target y) (the-as float (-> msg param 1)))
       (set! (-> self lerp) 0.375))
      (('shoot-left)   
       (process-spawn yellow-shot :init projectile-init-by-other (-> self entity) (-> self root trans) (static-vectorm -60 0 0) #f #f :to *target*))
      (('shoot-right)   
       (process-spawn yellow-shot :init projectile-init-by-other (-> self entity) (-> self root trans) (static-vectorm 60 0 0) #f #f :to *target*))
      (('shift)
       (set! (-> self shift) (-> msg param 0))
       (when (-> msg param 1)
         (set! (-> self target y) (- (-> self target y) (* (-> self shift) (meters 2.0))))
         (set! (-> self lerp) 0.2)
         (set! (-> self shift) 0)))))
  :code (behavior ()
    (loop
      (set! (-> self offset x) (lerp (-> self offset x) (-> self target x) (* (-> self lerp) DISPLAY_FPS_RATIO)))
      (set! (-> self offset y) (lerp (-> self offset y) (-> self target y) (* (-> self lerp) DISPLAY_FPS_RATIO)))
      (vector+! (-> self root trans) (-> self base) (-> self offset))
      (when (> (-> self look) 6)
        (vector-copy! (-> self root root-prim prim-core) (-> self root trans))
        (spawn (-> self part) (the-as vector (-> self root root-prim prim-core))))
      (when (= (-> self lost) #t)
        (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* (degrees 60) (seconds-per-frame))))
      (when (= (-> self notice) #t)
        (when (rand-vu-percent? 0.5)
          (let ((s5-0 (new 'stack-no-clear 'vector)))
            (set! (-> s5-0 quad) (-> self root trans quad))
              (dotimes (gp-3 3)
                (+! (-> s5-0 data gp-3) (rand-vu-float-range -5324.8 5324.8)))
              (eco-blue-glow s5-0)))
        (activate! (-> self smush) (lerp-scale (rand-vu-float-range 0.1 0.3) (rand-vu-float-range 0.0 0.02) 50000.0
          (-> *FACT-bank* suck-suck-dist) (-> *FACT-bank* suck-bounce-dist)) 60 60 1.0 1.0))
      (when (and (= (-> *load-state* want 0 name) 'title) (< (-> self root trans y) (meters -10.0)))
        (set! (-> self base y) (+ (-> self base y) (meters 650.0))))
      (when (!= (-> self smush amp) 0.0)
        (let ((f0-0 (update! (-> self smush))))
          (set! (-> self root scale x) (+ (-> self scale x) (/ f0-0 -2)))
          (set! (-> self root scale y) (+ (-> self scale y) f0-0))
          (set! (-> self root scale z) (+ (-> self scale z) (/ f0-0 -2)))))
      (suspend)))
  :post ja-post)

(deftype block-game (process-drawable)
  ((field   int 200)
   (shapes  (inline-array vector))
   (piece   int)
   (next    int)
   (x       int)
   (y       int)
   (volume  int)
   (level   int)
   (loaded  symbol)
   (lines   int)
   (extras  int)
   (timeout time-frame)
   (hold    time-frame)
   (gravity float)
   (clock   float)
   (score   int)
   (board   float)
   (lost    symbol)
   (title   symbol))
  (:state-methods block-game-idle))

(def-actor block-game
  :bounds (0 0 0 50)
  :art (idle-ja)
  :joints (align prejoint camera))

(defbehavior get-block block-game ((id int))
  (set! (-> *block* id) id)
  (search-process-tree self (lambda ((p process)) (and (= (-> p type) block) (= (-> (the block p) id) (-> *block* id))))))

(defmacro for-block (piece x y &rest body)
  `(let ((id 0))
    (dotimes (block-y 4)
      (dotimes (block-x 4)
        (when (!= (logand (the int (-> (-> self shapes ,piece) data block-y)) (ash 1 (- 3 block-x))) 0)
          (set! id (- id 1))
          (let* ((index (+ (* (+ ,y block-y) 10) (+ ,x block-x)))
                 (proc (get-block id))
                 (x-loc (* (the float (+ ,x block-x)) (meters 2.0)))
                 (y-loc (* (the float (+ ,y block-y)) (meters -2.0)))
                 (invalid (and (>= (+ ,y block-y) 0) (or (> (+ ,y block-y) 19) (!= (-> (-> self field) index) -1)))))
          ,@body))))))

(defbehavior look-down block-game ((index int))
  (let ((id (+ index 10)))
    (while (and (< id 200) (>= id 0))
      (when (!= (-> (-> self field) id) -1)
        (return (get-block id)))
      (set! id (+ id 10)))
    (the process #f)))

(defbehavior look-right block-game ((index int))
  (let ((id (+ index 1)))
    (while (and (<= id (+ (- index (mod index 10)) 9)) (< id 200) (>= id 0))
      (when (!= (-> (-> self field) id) -1)
        (return (get-block id)))
      (set! id (+ id 1)))
    (the process #f)))

(defbehavior look-left block-game ((index int))
  (let ((id (- index 1)))
    (while (and (>= id (- index (mod index 10))) (>= id 0) (< id 200))
      (when (!= (-> (-> self field) id) -1)
        (return (get-block id)))
      (set! id (- id 1)))
    (the process #f)))

(defbehavior move block-game ((piece int) (x int) (y int) (rotate symbol))
  (set! (-> self timeout) (current-time))
  (for-block piece x y
    (when (not (-> self title))
      (when (or invalid (and (not rotate) (or (< (+ x block-x) 0) (> (+ x block-x) 9))))
        (return #f)))
    (while (< (+ x block-x) 0)
      (set! x (+ x 1))
      (for-block piece x y
        (when invalid
          (return #f))))
    (while (> (+ x block-x) 9)
      (set! x (- x 1))
      (for-block piece x y
        (when invalid
          (return #f)))))
  (set! (-> self x) x)
  (set! (-> self y) y)
  (set! (-> self piece) piece)
  (for-block piece x y
    (send-event proc 'set-loc x-loc y-loc)
    (when (= (-> (the block proc) look) 9)
      (send-event (look-left index) 'notice)
      (send-event (look-right index) 'notice)
      (send-event (look-down index) 'notice)))
  #t)

(defbehavior game-over block-game ()
  (set! (-> self lost) #t)
  (dotimes (id 8)
    (send-event (get-block (- id 8)) 'lose)
    (suspend-for (seconds 0.04)))
  (dotimes (index 200)
    (let ((proc (get-block index)))
      (when proc
        (send-event proc 'lose)
        (suspend-for (seconds 0.04)))))
  (none))

(defbehavior new-piece block-game ()
  (set! (-> self clock) 0.0)
  (set! (-> self piece) (-> self next))
  (set! (-> self next) (* (rand-vu-int-range 0 6) 4))
  (set! (-> self x) 3)
  (set! (-> self y) -2)
  (when (not (move (-> self piece) (-> self x) (-> self y) #f))
    (game-over)
    (return #f))
  (for-block (-> self piece) 3 -2
    (set! proc (get-block (- id 4)))
    (send-event proc 'set-loc x-loc y-loc)
    (set! (-> (the block proc) id) id))
  (let ((look (rand-vu-int-range 1 300)))
    (case look
      ((1) (set! look 7))
      ((150) (set! look 8))
      ((300) (set! look 9))
      (else (set! look -1)))
    (for-block (-> self next) 11 2
      (let ((trans (new-stack-vector0))
            (base (new-stack-vector0)))
        (vector-copy! base (-> self root trans))
        (if (!= look -1)
          (set! (-> base y) (+ (-> base y) (meters 1.0))))
        (set-vector! trans (+ (-> base x) x-loc) (+ (-> base y) y-loc) (-> base z) 1.0)
        (process-spawn block trans base x-loc y-loc (- id 4) (if (!= look -1) look (/ (the-as int (-> self next)) 4)) :to self))))
  (none))

(defbehavior move-field block-game ()
  (dotimes (index 200)
    (send-event (get-block index) 'move-delay (-> self root trans x) (-> self root trans y) (-> self root trans z)))
  (for-block (-> self piece) 3 -2
    (set! proc (get-block id))
    (send-event proc 'move-delay (-> self root trans x) (-> self root trans y) (-> self root trans z)))
  (for-block (-> self next) 11 2
    (set! proc (get-block (- id 4)))
    (send-event proc 'move-delay (-> self root trans x) (-> self root trans y) (-> self root trans z)))
  (vector-copy! (-> (the process-drawable (process-by-name "block-camera-entity" *entity-pool*)) root trans) (-> self root trans))
  (none))

(defbehavior clean-level-actor block-game ((actor symbol))
  (process-entity-status! (process-by-name actor *active-pool*) (entity-perm-status dead) #t)
  (process-entity-status! (process-by-name actor *active-pool*) (entity-perm-status complete) #t)
  (kill-by-name actor *active-pool*)
  (none))

(defbehavior load-level block-game ((first symbol) (second symbol) (display symbol) (loc vector))
  (let ((wanted (if (= display 'first) first second))
        (extra (if (= display 'first) second first)))
    (when (!= (-> self loaded) wanted)
      (load-state-want-display-level wanted 'display-self)
      (load-state-want-display-level extra #f)
      (set! (-> self loaded) wanted)
      (vector-copy! (-> self root trans) loc)
      (set-force-inside! *load-state* wanted #t)
      (load-state-want-levels first second)
      (move-field)
      (case wanted
        (('beach) (play-main-music "beach.wav" (-> self volume)))
        (('jungle) (play-main-music "jungle.wav" (-> self volume)))
        (('firecanyon) (play-main-music "firecanyon.wav" (-> self volume)))
        (('sunken) (play-main-music "sunken.wav" (-> self volume)))
        (('snow) (play-main-music "snow.wav" (-> self volume)))))
    (when (> (mod (-> self lines) 10) 6)
      (when (= extra 'jungle)
        (clean-level-actor 'crate-11)
        (clean-level-actor 'crate-12))
      (load-state-want-display-level extra 'display-self)))
  (none))

(defbehavior set-level block-game ()
  (when (< (-> self level) (the int (/ (-> self lines) 10)))
    (set! (-> self level) (the int (/ (-> self lines) 10))))
  (set! (-> self gravity) (* 0.8 (exp (* -0.1589 (max 0 (-> self level))))))
  (case (mod (the int (/ (-> self lines) 10)) 10)
    ((0 1) (load-level 'beach 'jungle 'first (static-vectorm -198.0 40.0 -285.0)))
    ((2 3) (load-level 'firecanyon 'jungle 'second (static-vectorm 261.0 75.0 -266.0)))
    ((4 5) (load-level 'firecanyon 'sunken 'first (static-vectorm 135.14 69.0 -480.0)))
    ((6 7) (load-level 'snow 'sunken 'second (static-vectorm 840.0 -103.0 -1628.0)))
    ((8 9) (load-level 'snow 'beach 'first (static-vectorm 661.0 295.0 -3316.0))))
  (if (>= (mod (-> self lines) 200) 100)
    (set-time-of-day 23.0)
    (set-time-of-day 9.0))
  (none))

(defbehavior shift-down block-game ((id int) (amount int) (now symbol))
  (let ((proc (get-block id)))
    (when (and proc (> amount 0))
      (send-event proc 'shift amount now)
      (set! (-> (the block proc) id) (+ id (* 10 amount)))
      (set! (-> (-> self field) (+ id (* 10 amount))) (-> (-> self field) id))
      (set! (-> (-> self field) id) -1)))
  (none))

(defbehavior red-effect block-game ()
  (dotimes (count 200)
    (let ((index (- 199 count)))
      (when (!= (-> (-> self field) index) -1)
        (let ((search (+ index 10))
              (spaces 0))
          (while (and (< search 200) (= (-> (-> self field) search) -1))
            (set! spaces (+ spaces 1))
            (set! search (+ search 10)))
          (when (> spaces 0)
            (shift-down index spaces #t)
            (suspend-for (seconds 0.006)))))))
  (none))

(defbehavior break-extra block-game ((proc process))
  (set! (-> self extras) (+ (-> self extras) 1))
  (set! (-> (-> self field) (-> (the block proc) id)) -1)
  (when (= (mod (-> self extras) 3) 0)
    (sound-play-by-spec (static-sound-spec "icrate-break" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
  (send-event proc 'break)
  (none))

(defbehavior yellow-effect block-game ()
  (let ((clears 0))
    (dotimes (row 20)
      (let ((y (* (- 19 row) 10))
            (leftmost 200)
            (leftmost-id -100)
            (rightmost -1)
            (rightmost-id -100))
        (for-block (-> self piece) (-> self x) (-> self y)
          (when (and (>= index y) (< index (+ y 10)))
            (when (< index leftmost)
              (set! leftmost index)
              (set! leftmost-id id))
            (when (> index rightmost)
              (set! rightmost index)
              (set! rightmost-id id))))
        (when (or (!= leftmost-id -100) (!= rightmost-id -100))
          (set! clears (+ clears 1))
          (when (> (mod leftmost 10) 0)
            (send-event (get-block leftmost-id) 'shoot-left))
          (dotimes (count 9)
            (when (look-right leftmost)
              (break-extra (look-right leftmost))
              (suspend-for (seconds 0.018))))
          (when (< (mod rightmost 10) 9)
            (send-event (get-block rightmost-id) 'shoot-right))
          (dotimes (count 9)
            (when (look-left rightmost)
              (break-extra (look-left rightmost))
              (suspend-for (seconds 0.018)))))
        (when (and (= leftmost-id -100) (= rightmost-id -100))
          (dotimes (x 10)
            (shift-down (+ y x) clears #f))))))
  (none))

(defbehavior award-score block-game ((clears int))
  (set! clears (+ (* clears 10) (-> self extras)))
  (let ((fraction 0))
    (cond
      ((>= clears 40) (set! fraction 120))
      ((>= clears 30) (set! fraction 30))
      ((>= clears 20) (set! fraction 10))
      ((>= clears 10) (set! fraction 4)))
    (set! (-> self score) (+ (-> self score) (* (* fraction clears) (+ (-> self level) 1))))
    (set! (-> self extras) 0))
  (none))

(defbehavior end-turn block-game ((look int))
  (when (= look 8)
    (yellow-effect))
  (for-block (-> self piece) (-> self x) (-> self y)
    (when (>= index 0)
      (set! (-> (-> self field) index) look)
      (send-event proc 'place))
    (when (< index 0)
      (send-event proc 'break))
    (set! (-> (the block proc) id) index))
  (when (= look 7)
    (red-effect))
  (let ((clears 0))
    (when (!= look 8)
      (dotimes (row 20)
        (let ((count-x 0)
              (y (* (- 19 row) 10)))
          (dotimes (x 10)
            (when (!= (-> (-> self field) (+ y x)) -1)
              (set! count-x (+ count-x 1))))
          (when (= count-x 10)
            (set! clears (+ clears 1))
            (dotimes (x 10)
              (set! (-> (-> self field) (+ y x)) -1)
              (send-event (get-block (+ y x)) 'break)
              (when (= (mod x 3) 0)
                (sound-play-by-spec (static-sound-spec "icrate-break" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
              (suspend-for (seconds 0.035))))
          (when (< count-x 10)
            (dotimes (x 10)
              (shift-down (+ y x) clears #f)))))
        (set! (-> self lines) (+ (-> self lines) clears))
        (when (= look 9)
          (dotimes (count 200)
            (let ((proc (get-block (- 199 count))))
              (when (and proc (= (-> (the block proc) notice) #t))
                (break-extra proc)
                (suspend-for (seconds 0.035)))))))
    (award-score clears))
  (dotimes (count 200)
    (let ((proc (get-block (- 199 count))))
      (when (and proc (> (-> (the block proc) shift) 0))
        (send-event proc 'shift (-> (the block proc) shift) #t)
        (suspend-for (seconds 0.006)))))
  (set-level)
  (dotimes (index 200)
    (when (> (-> (-> self field) index) 6)
      (send-event (get-block index) 'break)
      (set! (-> (-> self field) index) -1)))
  (new-piece)
  (none))

(defbehavior block-game-init block-game ((this block-game))
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this level) (the int (the-as float (-> *progress-carousell* int-backup))))
  (set! (-> this score) 0)
  (dotimes (index 200)
    (set! (-> this field index) -1))
  (set! (-> this shapes) (new 'static 'inline-array vector 28
    (static-vector 0.0 0.0 6.0 6.0) (static-vector 0.0 0.0 6.0 6.0) (static-vector 0.0 0.0 6.0 6.0) (static-vector 0.0 0.0 6.0 6.0)
    (static-vector 0.0 0.0 15.0 0.0) (static-vector 2.0 2.0 2.0 2.0) (static-vector 0.0 0.0 15.0 0.0) (static-vector 2.0 2.0 2.0 2.0)
    (static-vector 0.0 0.0 7.0 1.0) (static-vector 0.0 2.0 2.0 6.0) (static-vector 0.0 4.0 7.0 0.0) (static-vector 0.0 3.0 2.0 2.0)
    (static-vector 0.0 0.0 7.0 4.0) (static-vector 0.0 6.0 2.0 2.0) (static-vector 0.0 1.0 7.0 0.0) (static-vector 0.0 2.0 2.0 3.0)
    (static-vector 0.0 0.0 3.0 6.0) (static-vector 0.0 2.0 3.0 1.0) (static-vector 0.0 0.0 3.0 6.0) (static-vector 0.0 2.0 3.0 1.0)
    (static-vector 0.0 0.0 7.0 2.0) (static-vector 0.0 2.0 6.0 2.0) (static-vector 0.0 2.0 7.0 0.0) (static-vector 0.0 2.0 3.0 2.0)
    (static-vector 0.0 0.0 6.0 3.0) (static-vector 0.0 1.0 3.0 2.0) (static-vector 0.0 0.0 6.0 3.0) (static-vector 0.0 1.0 3.0 2.0)))
  (none))

(defbehavior block-game-init-by-other block-game ()
  (stack-size-set! (-> self main-thread) 1024)
  (block-game-init self)
  (set! (-> self title) #f)
  (set! (-> *time-of-day-proc* 0 time-ratio) 0.0)
  (logior! (-> *target* draw status) (draw-status hidden))
  (set! (-> self volume) (the int (* (-> *setting-control* default music-volume) 1.5)))
  (set! (-> *setting-control* default music-volume) 0.0)
  (let ((proc (process-spawn block-camera :init pov-camera-init-by-other (-> self root trans) *block-game-sg* "idle" 0 self '()
    :name "block-camera-entity" :to self)))
    (send-event (ppointer->process proc) 'mask 0))
  (set-level)
  (go (method-of-object self block-game-idle))
  (none))

(defmethod init-from-entity! ((this block-game) (arg0 entity-actor))
  (block-game-init this)
  (process-drawable-from-entity! this arg0)
  (set! (-> this title) #t)
  (set! (-> this gravity) (rand-vu-float-range 0.2 0.5))
  (go (method-of-object this block-game-idle))
  (none))

(defbehavior draw-line block-game ((loc vector) (start-x int) (start-y int) (end-x int) (end-y int))
  (let ((start (new-stack-vector0))
        (end (new-stack-vector0)))
    (set-vector! start (+ (-> loc x) (* start-x (meters 0.975))) (+ (-> loc y) (* start-y (meters 0.975))) (-> loc z) 1.0)
    (set-vector! end (+ (-> loc x) (* end-x (meters 0.975))) (+ (-> loc y) (* end-y (meters 0.975))) (-> loc z) 1.0)
    (draw-eco-line start end 3001))
  (none))

(defbehavior draw-digit block-game ((loc vector) (value int))
  (let ((bit (case value
             ((0) 119) ((1) 18) ((2) 93) ((3) 91) ((4) 58)
             ((5) 107) ((6) 111) ((7) 82) ((8) 127) ((9) 122))))
    (if (nonzero? (logand bit (ash 1 0))) (draw-line loc 1 0 0 0))
    (if (nonzero? (logand bit (ash 1 1))) (draw-line loc 1 0 1 1))
    (if (nonzero? (logand bit (ash 1 2))) (draw-line loc 0 0 0 1))
    (if (nonzero? (logand bit (ash 1 3))) (draw-line loc 1 1 0 1))
    (if (nonzero? (logand bit (ash 1 4))) (draw-line loc 1 1 1 2))
    (if (nonzero? (logand bit (ash 1 5))) (draw-line loc 0 1 0 2))
    (if (nonzero? (logand bit (ash 1 6))) (draw-line loc 1 2 0 2))
  (none)))

(defbehavior draw-score block-game ((loc vector) (score float) (start int))
  (let ((trans (new-stack-vector0))
        (digit 100000))
    (vector-copy! trans loc)
    (dotimes (count 6)
      (when (>= count start)
        (set! (-> trans x) (the-as float (+ (-> loc x) (* count (meters 1.7)))))
        (draw-digit trans (mod (the int (/ score digit)) 10)))
      (set! digit (the int (/ digit 10)))))
  (none))

(defbehavior hold-button block-game ((button int) (x int) (y int))
  (when (or (logtest? (cpad-pressed 0) button)
            (and (logtest? (cpad-hold 0) button) (time-elapsed? (-> self timeout) (seconds 0.02)) (time-elapsed? (-> self hold) (seconds 0.12))))
    (when (logtest? (cpad-pressed 0) button)
      (set! (-> self hold) (current-time)))
    (move (-> self piece) x y #f)))

(defstate block-game-idle (block-game)
  :virtual #t
  :enter (behavior ()
    (set! (-> self next) (* (rand-vu-int-range 0 6) 4))
    (set! (-> self piece) (-> self next))
    (for-block (-> self piece) 3 -2
      (let ((trans (new-stack-vector0)))
        (set-vector! trans (+ (-> self root trans x) x-loc) (+ (-> self root trans y) y-loc) (-> self root trans z) 1.0)
        (process-spawn block trans (-> self root trans) x-loc y-loc id (/ (the-as int (-> self next)) 4) :to self)))
    (when (not (-> self title))
      (new-piece)))
  :code (behavior ()
    (loop
      (when (and (!= (-> self lost) #t) (!= (-> self title) #t))
        (when (or (hold-button (ash 1 7) (- (-> self x) 1) (-> self y))
                  (hold-button (ash 1 5) (+ (-> self x) 1) (-> self y)))
          (sound-play-by-spec (static-sound-spec "walk-stone1" :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
        (when (hold-button (ash 1 6) (-> self x) (+ (-> self y) 1))
          (set! (-> self clock) 0.0)
          (set! (-> self score) (+ (-> self score) 1)))
        (when (cpad-pressed? 0 up)
          (while (move (-> self piece) (-> self x) (+ (-> self y) 1) #f))
          (set! (-> self score) (+ (-> self score) 2))
          (suspend-for (seconds 0.15))
          (end-turn (-> (the block (get-block -1)) look)))
        (when (and (cpad-pressed? 0 circle)
              (move (if (= (mod (-> self piece) 4) 3) (- (-> self piece) 3) (+ (-> self piece) 1)) (-> self x) (-> self y) #t))
          (sound-play-by-spec (static-sound-spec "roll-stone" :volume 1000 :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
        (when (and (cpad-pressed? 0 x)
              (move (if (= (mod (-> self piece) 4) 0) (+ (-> self piece) 3) (- (-> self piece) 1)) (-> self x) (-> self y) #t))
          (sound-play-by-spec (static-sound-spec "roll-stone" :volume 1000 :fo-min 200 :fo-max 400) (new-sound-id) (the-as vector #t)))
        (when (>= (-> self clock) (-> self gravity))
          (set! (-> self clock) 0.0)
          (when (not (move (-> self piece) (-> self x) (+ (-> self y) 1) #f))
            (end-turn (-> (the block (get-block -1)) look)))))
      (when (-> self title)
        (let ((action (rand-vu-int-range 1 (* 2 (-> *display* frames-per-second)))))
          (case action
            ((1) (move (if (= (mod (-> self piece) 4) 0) (+ (-> self piece) 3) (- (-> self piece) 1)) (-> self x) (-> self y) #t))
            ((15) (move (-> self piece) (- (-> self x) (rand-vu-int-range 1 2)) (-> self y) #f))
            ((30) (move (-> self piece) (+ (-> self x) (rand-vu-int-range 1 2)) (-> self y) #f)))
        (when (>= (-> self clock) (-> self gravity))
          (set! (-> self clock) 0.0)
          (move (-> self piece) (-> self x) (+ (-> self y) 1) #f))))
      (suspend)))
  :post (behavior ()
    (when (!= (-> self lost) #t)
      (set! (-> self clock) (+ (-> self clock) (* 1.0 (seconds-per-frame)))))
    (set! *teleport* #t)
    (when (not (-> self title))
      (let ((start (new-stack-vector0))
            (end (new-stack-vector0))
            (score (new-stack-vector0))
            (lines (new-stack-vector0))
            (level (new-stack-vector0))
            (target (new-stack-vector0)))
        (vector+! target (-> self root trans) (static-vectorm 9.0 -18.0 12.0))
        (when (= (-> self loaded) 'beach)
          (set! (-> target z) (+ (-> target z) (meters 30.0))))
        (vector-copy! (-> *target* control trans) target)
        (vector+! score (-> self root trans) (static-vectorm 21.5 -4.25 0.0))
        (set! (-> self board) (lerp (-> self board) (the float (-> self score)) (* 0.2 DISPLAY_FPS_RATIO)))
        (draw-score score (+ (-> self board) 0.1) 0)
        (vector+! lines (-> self root trans) (static-vectorm 21.5 -1.0 0.0))
        (draw-score lines (the float (-> self lines)) 3)
        (vector+! level (-> self root trans) (static-vectorm -13.5 -1.0 0.0))
        (draw-score level (the float (-> self level)) 4)
        (vector+! start (-> self root trans) (static-vectorm -1.5 2.0 0.0))
        (vector+! end (-> self root trans) (static-vectorm -1.5 -38.0 0.0))
        (draw-eco-line start end 3000)
        (vector+! start (-> self root trans) (static-vectorm 19.5 2.0 0.0))
        (vector+! end (-> self root trans) (static-vectorm 19.5 -38.0 0.0))
        (draw-eco-line start end 3000)))
    (ja-post)))

(defun spawn-block-game ()
  (process-spawn block-game :name "block-game-entity" :to *entity-pool*)
  (none))

